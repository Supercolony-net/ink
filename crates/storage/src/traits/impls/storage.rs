// Copyright 2018-2022 Parity Technologies (UK) Ltd.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use crate::traits::{
    storage::Storable,
    AutoItem,
    Item,
    KeyHolder,
    Packed,
};
use core::{
    fmt::Debug,
    marker::PhantomData,
};
use ink_primitives::{
    Key,
    KeyComposer,
};
use scale::{
    Error,
    Input,
    Output,
};

/// Auto key type means that the storage key should be calculated automatically.
#[derive(Default, Copy, Clone, PartialEq, Eq, PartialOrd, Debug)]
#[cfg_attr(feature = "std", derive(scale_info::TypeInfo))]
pub struct AutoKey;

impl KeyHolder for AutoKey {
    const KEY: Key = 0;
}

/// Manual key type specifies the storage key.
#[derive(Default, Copy, Clone, Eq, PartialEq, PartialOrd, Debug)]
#[cfg_attr(feature = "std", derive(scale_info::TypeInfo))]
pub struct ManualKey<const KEY: Key, Salt: KeyHolder = ()>(PhantomData<fn() -> Salt>);

impl<const KEY: Key, Salt: KeyHolder> KeyHolder for ManualKey<KEY, Salt> {
    const KEY: Key = KeyComposer::concat(KEY, Salt::KEY);
}

/// Resolver key type selects between preferred key and autogenerated key.
/// If the `L` type is `AutoKey` it returns auto-generated `R` else `L`.
#[derive(Default, Copy, Clone, PartialEq, Eq, PartialOrd, Debug)]
#[cfg_attr(feature = "std", derive(scale_info::TypeInfo))]
pub struct ResolverKey<L: KeyHolder, R: KeyHolder>(PhantomData<fn() -> (L, R)>);

impl<L: KeyHolder, R: KeyHolder> KeyHolder for ResolverKey<L, R> {
    /// `KEY` of the `AutoKey` is zero. If left key is zero, then use right manual key.
    const KEY: Key = if L::KEY == 0 { R::KEY } else { L::KEY };
}

impl<T, const KEY: Key, Salt> AutoItem<ManualKey<KEY, Salt>> for T
where
    T: Item<Salt>,
    T: Item<ResolverKey<<T as Item<Salt>>::PreferredKey, ManualKey<KEY, Salt>>>,
    Salt: KeyHolder,
{
    type Type = <T as Item<
        ResolverKey<<T as Item<Salt>>::PreferredKey, ManualKey<KEY, Salt>>,
    >>::Type;
}

impl<P> Packed for P where P: scale::Decode + scale::Encode {}

impl<P> Storable for P
where
    P: Packed,
{
    #[inline]
    fn encode<T: Output + ?Sized>(&self, dest: &mut T) {
        scale::Encode::encode_to(self, dest)
    }

    #[inline]
    fn decode<I: Input>(input: &mut I) -> Result<Self, Error> {
        scale::Decode::decode(input)
    }
}

impl<P> KeyHolder for P
where
    P: Packed,
{
    const KEY: Key = 0;
}

impl<P, Salt> Item<Salt> for P
where
    P: Packed,
    Salt: KeyHolder,
{
    type Type = P;
    type PreferredKey = AutoKey;
}
