use crate::traits::{
    AutoStorageType,
    StorageKeyHolder,
    StorageType,
};
use core::{
    fmt::Debug,
    marker::PhantomData,
};
use ink_primitives::StorageKey;

/// Auto key type means that the storage key should be calculated automatically.
#[derive(Default, Copy, Clone, PartialEq, PartialOrd, Debug)]
#[cfg_attr(feature = "std", derive(scale_info::TypeInfo))]
pub struct AutoKey;

impl StorageKeyHolder for AutoKey {
    const KEY: StorageKey = 0;
}

/// Manual key type specifies the storage key.
#[derive(Default, Copy, Clone, PartialEq, PartialOrd, Debug)]
#[cfg_attr(feature = "std", derive(scale_info::TypeInfo))]
pub struct ManualKey<const KEY: StorageKey, Salt: StorageKeyHolder = ()>(
    PhantomData<fn() -> Salt>,
);

impl<const KEY: StorageKey, Salt: StorageKeyHolder> StorageKeyHolder
    for ManualKey<KEY, Salt>
{
    // TODO: Use XoR here or better to calculate const hash during compilation?
    const KEY: StorageKey = KEY ^ Salt::KEY;
}

/// Resolver key type selects between preferred key and autogenerated key.
/// If the `L` type is `AutoKey` it returns auto-generated `R` else `L`.
#[derive(Default, Copy, Clone, PartialEq, PartialOrd, Debug)]
#[cfg_attr(feature = "std", derive(scale_info::TypeInfo))]
pub struct ResolverKey<L: StorageKeyHolder, R: StorageKeyHolder>(
    PhantomData<fn() -> (L, R)>,
);

impl<L: StorageKeyHolder, R: StorageKeyHolder> StorageKeyHolder for ResolverKey<L, R> {
    /// `KEY` of the `AutoKey` is zero. If left key is zero, then use right manual key.
    const KEY: StorageKey = if L::KEY == 0 { R::KEY } else { L::KEY };
}

impl<T, const KEY: StorageKey, Salt> AutoStorageType<ManualKey<KEY, Salt>> for T
where
    T: StorageType<Salt>,
    T: StorageType<
        ResolverKey<<T as StorageType<Salt>>::PreferredKey, ManualKey<KEY, Salt>>,
    >,
    Salt: StorageKeyHolder,
{
    type Type = <T as StorageType<
        ResolverKey<<T as StorageType<Salt>>::PreferredKey, ManualKey<KEY, Salt>>,
    >>::Type;
}
