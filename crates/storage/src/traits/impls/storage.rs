// Copyright 2018-2022 Parity Technologies (UK) Ltd.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use crate::traits::{
    AutoStorageType,
    StorageKeyHolder,
    StorageType,
};
use core::{
    fmt::Debug,
    marker::PhantomData,
};
use ink_primitives::{
    StorageKey,
    StorageKeyComposer,
};

/// Auto key type means that the storage key should be calculated automatically.
#[derive(Default, Copy, Clone, PartialEq, PartialOrd, Debug)]
#[cfg_attr(feature = "std", derive(scale_info::TypeInfo))]
pub struct AutoKey;

impl StorageKeyHolder for AutoKey {
    const KEY: StorageKey = 0;
}

/// Manual key type specifies the storage key.
#[derive(Default, Copy, Clone, PartialEq, PartialOrd, Debug)]
#[cfg_attr(feature = "std", derive(scale_info::TypeInfo))]
pub struct ManualKey<const KEY: StorageKey, Salt: StorageKeyHolder = ()>(
    PhantomData<fn() -> Salt>,
);

impl<const KEY: StorageKey, Salt: StorageKeyHolder> StorageKeyHolder
    for ManualKey<KEY, Salt>
{
    const KEY: StorageKey = StorageKeyComposer::concat(KEY, Salt::KEY);
}

/// Resolver key type selects between preferred key and autogenerated key.
/// If the `L` type is `AutoKey` it returns auto-generated `R` else `L`.
#[derive(Default, Copy, Clone, PartialEq, PartialOrd, Debug)]
#[cfg_attr(feature = "std", derive(scale_info::TypeInfo))]
pub struct ResolverKey<L: StorageKeyHolder, R: StorageKeyHolder>(
    PhantomData<fn() -> (L, R)>,
);

impl<L: StorageKeyHolder, R: StorageKeyHolder> StorageKeyHolder for ResolverKey<L, R> {
    /// `KEY` of the `AutoKey` is zero. If left key is zero, then use right manual key.
    const KEY: StorageKey = if L::KEY == 0 { R::KEY } else { L::KEY };
}

impl<T, const KEY: StorageKey, Salt> AutoStorageType<ManualKey<KEY, Salt>> for T
where
    T: StorageType<Salt>,
    T: StorageType<
        ResolverKey<<T as StorageType<Salt>>::PreferredKey, ManualKey<KEY, Salt>>,
    >,
    Salt: StorageKeyHolder,
{
    type Type = <T as StorageType<
        ResolverKey<<T as StorageType<Salt>>::PreferredKey, ManualKey<KEY, Salt>>,
    >>::Type;
}
