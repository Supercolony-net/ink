// Copyright 2018-2022 Parity Technologies (UK) Ltd.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use crate::traits::{
    AutoItem,
    Item,
    Packed,
    StorageKey,
};
use core::{
    fmt::Debug,
    marker::PhantomData,
};
use ink_primitives::{
    Key,
    KeyComposer,
};

/// Auto key type means that the storage key should be calculated automatically.
#[derive(Default, Copy, Clone, PartialEq, Eq, PartialOrd)]
#[cfg_attr(feature = "std", derive(scale_info::TypeInfo))]
pub struct AutoKey;

impl StorageKey for AutoKey {
    const KEY: Key = 0;
}

impl Debug for AutoKey {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("AutoKey")
            .field("key", &<Self as StorageKey>::KEY)
            .finish()
    }
}

/// Manual key type specifies the storage key.
#[derive(Default, Copy, Clone, Eq, PartialEq, PartialOrd)]
#[cfg_attr(feature = "std", derive(scale_info::TypeInfo))]
pub struct ManualKey<const KEY: Key, ParentKey: StorageKey = ()>(
    PhantomData<fn() -> ParentKey>,
);

impl<const KEY: Key, ParentKey: StorageKey> StorageKey for ManualKey<KEY, ParentKey> {
    const KEY: Key = KeyComposer::concat(KEY, ParentKey::KEY);
}

impl<const KEY: Key, ParentKey: StorageKey> Debug for ManualKey<KEY, ParentKey> {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("ManualKey")
            .field("key", &<Self as StorageKey>::KEY)
            .finish()
    }
}

/// Resolver key type selects between preferred key and autogenerated key.
/// If the `L` type is `AutoKey` it returns auto-generated `R` else `L`.
#[derive(Default, Copy, Clone, PartialEq, Eq, PartialOrd, Debug)]
#[cfg_attr(feature = "std", derive(scale_info::TypeInfo))]
pub struct ResolverKey<L: StorageKey, R: StorageKey>(PhantomData<fn() -> (L, R)>);

impl<L: StorageKey, R: StorageKey> StorageKey for ResolverKey<L, R> {
    /// `KEY` of the `AutoKey` is zero. If left key is zero, then use right manual key.
    const KEY: Key = if L::KEY == 0 { R::KEY } else { L::KEY };
}

type FinalKey<T, const KEY: Key, ParentKey> =
    ResolverKey<<T as Item<ParentKey>>::PreferredKey, ManualKey<KEY, ParentKey>>;

// `AutoItem` trait figures out that storage key it should use.
// - If the `PreferredKey` is `AutoKey` it will use an auto-generated key passed as generic
// into `AutoItem`.
// - If `PreferredKey` is `ManualKey`, then it will use it.
impl<T, const KEY: Key, ParentKey> AutoItem<ManualKey<KEY, ParentKey>> for T
where
    T: Item<ParentKey>,
    T: Item<FinalKey<T, KEY, ParentKey>>,
    ParentKey: StorageKey,
{
    type Type = <T as Item<FinalKey<T, KEY, ParentKey>>>::Type;
}

impl<P> Packed for P where P: scale::Decode + scale::Encode {}

impl<P> StorageKey for P
where
    P: Packed,
{
    const KEY: Key = 0;
}

impl<P, Key> Item<Key> for P
where
    P: Packed,
    Key: StorageKey,
{
    type Type = P;
    type PreferredKey = AutoKey;
}

#[cfg(test)]
mod tests {
    mod arrays {
        use crate::item_works_for_primitive;

        type Array = [i32; 4];
        item_works_for_primitive!(Array);

        type ArrayTuples = [(i32, i32); 2];
        item_works_for_primitive!(ArrayTuples);
    }

    mod prims {
        use crate::item_works_for_primitive;
        use ink_env::AccountId;

        item_works_for_primitive!(bool);
        item_works_for_primitive!(String);
        item_works_for_primitive!(AccountId);
        item_works_for_primitive!(i8);
        item_works_for_primitive!(i16);
        item_works_for_primitive!(i32);
        item_works_for_primitive!(i64);
        item_works_for_primitive!(i128);
        item_works_for_primitive!(u8);
        item_works_for_primitive!(u16);
        item_works_for_primitive!(u32);
        item_works_for_primitive!(u64);
        item_works_for_primitive!(u128);

        type OptionU8 = Option<u8>;
        item_works_for_primitive!(OptionU8);

        type ResultU8 = Result<u8, bool>;
        item_works_for_primitive!(ResultU8);

        type BoxU8 = Box<u8>;
        item_works_for_primitive!(BoxU8);

        type BoxOptionU8 = Box<Option<u8>>;
        item_works_for_primitive!(BoxOptionU8);
    }

    mod tuples {
        use crate::item_works_for_primitive;

        type TupleSix = (i32, u32, String, u8, bool, Box<Option<i32>>);
        item_works_for_primitive!(TupleSix);
    }
}
